#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

/*
 Задание:

 1. Написать программу, исходные данные: дан отрезок [a, b] - вводим с клавиатеры,
 и функция, по которой будем считать значения в узлах. Используем многочлен второй степени (3 узла),
 и они равноотстощие на отрезке [a, b]. С помощью двойного цикла запрограммировать вычисление
 многочлена Лагранжа в произволной точке x. --- См. interpolate1

 2. Функция f задана таблицей значений. Найти с помощью многочлена Лагранжа L2(x) приближенное значение
 функции в точках x* = 1.5 и x** = 2.5  --- См. interpolate2
 */

typedef double (*func)(double a);

// Функция, которая будет передаваться как параметр (можно написать любую)
double f(double x){
    double y = x*x-3; // Можно написать другую // double y = (1-x)/(1+x*x);
    return y;
}

// Функция вычисления ошибки:
double delta(double y1, double y2){
    return abs(y1 - y2);
}


// Основная функция интерполяции (объявление)
double interpolate2(vector<double> X, vector<double> Y, double xx);

// Вспомогательная функция интерполяции (+ расчет весторов X и Y) (объявление)
double interpolate1(double a, double b, int size, double xx, func f);

// Основная программа:
int main() {
    std::cout << "Интерполяция многочленом Лагранжа" << std::endl;

    // Две части, ненужную закомментировать


    // Часть первая: известен интервал и функция, выполняем разбиение для многочлена степени n (на n+1 узлов):
    int n = 2; // Многочлен степени 2 = число узлов 3
    double a =1.0, b = 3.0; // Интервал
    double xx = 2.5; // Точка внутри интервала, для которой выполняется интерполяция
    // а f - функция исходная, нам она нужна чтобы посчитать в узлах значения f(x)
    // Выполняем интерполяцию через вспомогательную функцию:
    double yy = interpolate1(a, b, n+1, xx, f);
    // А также вычисляем истинное значение функции в этой точке:
    double y = f(xx);
    // Выводим результат:
    std::cout << "L" << n << "(" << xx << ") = " << yy << std::endl;
    std::cout << "f" << "(" << xx << ") = " << y << std::endl;


    // Часть вторая: известны узловые точки и функция, выполняем интерполяцию для xx:
    vector<double> myX; // Создаем пустой вектор X
    myX.insert(myX.end(), 1.0); // добавляем в конец вектора
    myX.insert(myX.end(), 2.0);
    myX.insert(myX.end(), 3.0);
    //myX[0] = 1.0; myX[1] = 2.0; myX[2] = 3.0; // Так тоже можно, но не забыть задать размер vector<double> myX(3);
    vector<double> myY; // Создаем пустой вектор Y
    myY.insert(myY.end(), -2.0);
    myY.insert(myY.end(), 1.0);
    myY.insert(myY.end(), 6.0);
    //myY[0] = -2.0; myY[1] = 1.0; myY[2] = 6.0;

    double xx1 = 2.5; // Точка внутри интервала, для которой выполняется интерполяция
    // а f - функция исходная, нам она нужна чтобы посчитать в узлах значения f(x)
    // Выполняем интерполяцию через основную функцию:
    double yy1 = interpolate2(myX, myY, xx);
    // А также вычисляем истинное значение функции в этой точке:
    double y1 = f(xx1);
    // Выводим результат:
    std::cout << "L" << myX.size()-1 << "(" << xx1 << ") = " << yy1 << std::endl;
    std::cout << "f" << "(" << xx1 << ") = " << y1 << std::endl;


    return 0;
}

// Основная функция интерполяции
double interpolate2(vector<double> X, vector<double> Y, double xx){
    double sum = 0.0; // Сумма-накопитель
    for (int i = 0; i < X.size(); i++){
        double pp = Y[i];
        for (int j = 0; j < X.size(); j++){
            if (i != j){
                pp *= (xx - X[j]) / (X[i] - X[j]);
            }
        }
        sum += pp;
    }
    return sum;
}

// Вспомогательная функция интерполяции (+ расчет весторов X и Y)
double interpolate1(double a, double b, int size, double xx, func f){
    // Передаем в функцию границы отрезка a и b, число разбиений (узлов) этого отрезка size
    // и значение xx, для которого ищем y, а также функция f, для которой это все ищется
    vector<double> X(size); // Формируем вектор X (пустой)
    vector<double> Y(size); // Формируем вектор Y (пустой)
    double delta = abs(a - b) / (size-1); // Находим интервал разбиения
    X[0] = a; X[size-1] = b; // Начао и конец отрезка

    for (int i = 1; i < size-1; i++){ // Заполняем вектор X
        X[i] = X[i-1] + delta;
    }

    for (int i = 0; i < size; i++){ // Заполняем вектор Y
        Y[i] = f(X[i]);
    }

    // И вызываем основную функцию
    return interpolate2(X, Y, xx);
}
