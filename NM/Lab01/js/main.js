/*
 Задание:

 1. Написать программу, исходные данные: дан отрезок [a, b] - вводим с клавиатеры,
 и функция, по которой будем считать значения в узлах. Используем многочлен второй степени (3 узла),
 и они равноотстощие на отрезке [a, b]. С помощью двойного цикла запрограммировать вычисление
 многочлена Лагранжа в произволной точке x. --- См. interpolate1

 2. Функция f задана таблицей значений. Найти с помощью многочлена Лагранжа L2(x) приближенное значение
 функции в точках x* = 1.5 и x** = 2.5  --- См. interpolate2
 */


	// Функция, которая будет передаваться как параметр (можно написать любую)
	function f(x) {
		return (1-x)/(1+x*x); // return x*x
    }

    // Функция вычисления ошибки:
    function deltas(y1, y2) {
		return Math.abs(y1-y2);
    }

    // Основная функция интерполяции
	function interpolate2(X, Y, xx) {
		var sum = 0.0; // Сумма-накопитель
		for (var i = 0; i < X.length; i++){
			var pp = Y[i];
			for (var j = 0; j < X.length; j++){
				if (i != j){
					pp *= (xx - X[j]) / (X[i] - X[j]);
				}
			}
			sum += pp;
		}
		return sum;
    }

    // Вспомогательная функция интерполяции (+ расчет весторов X и Y)
	function interpolate1(a, b, size, xx) {
        // Передаем в функцию границы отрезка a и b, число разбиений (узлов) этого отрезка size
        // и значение xx, для которого ищем y, а также функция f, для которой это все ищется
		var X = []; // Формируем массив X (пустой)
		var Y = []; // Формируем массив Y (пустой)
		var delta = Math.abs(a - b) / (size - 1); // Находим интервал разбиения
		X.push(a); // Начало отрезка
		for (var i = 1; i < size - 1; i++){ // Заполняем вектор X
			X.push(X[i-1] + delta);
		}
		X.push(b); // Конец отрезка
        for (var i = 0; i < size; i++){ // Заполняем вектор Y
            Y.push(f(X[i]));
        }

        // И вызываем основную функцию
		return interpolate2(X, Y, xx);
    }


    // Функция печати гугл-чарт графика
    function drawChart() {

		var data = new google.visualization.DataTable();
		data.addColumn('number', 'Значение X');
		data.addColumn('number', 'График функции');
		data.addColumn('number', 'График полинома');

		var nn = 100;

		var X = []; // Формируем массив X (пустой)
		var Y = []; // Формируем массив Y (пустой)
		var delta = Math.abs(a - b) / (nn - 1); // Находим интервал разбиения
		X.push(a); // Начало отрезка
		for (var i = 1; i < nn - 1; i++){ // Заполняем вектор X
			X.push(X[i-1] + delta);
		}
		X.push(b); // Конец отрезка


		var Z = [nn];
		for (var i = 0; i < nn; i++){
			Z[i] = [3];
			Z[i][0] = X[i];
			Z[i][1] = f(X[i]);
			Z[i][2] = interpolate1(a, b, n+1, X[i]);
		}

        data.addRows(Z);
        /*
        data.addRows([
            [1,  37.8, 80.8],
            [2,  30.9, 69.5],
            [3,  25.4,   57],
            [4,  11.7, 18.8],
            [5,  11.9, 17.6],
            [6,   8.8, 13.6],
            [7,   7.6, 12.3],
            [8,  12.3, 29.2],
            [9,  16.9, 42.9],
            [10, 12.8, 30.9],
            [11,  5.3,  7.9],
            [12,  6.6,  8.4],
            [13,  4.8,  6.3],
            [14,  4.2,  6.2]
        ]);
		*/

        var options = {
            chart: {
                title: 'Полиномиальная интерполяция (полином Лагранжа)',
                subtitle: 'сравнение с графиком оригинальной функции F(x)'
            },
            width: 900,
            height: 500,
            axes: {
                x: {
                    0: {side: 'top'}
                }
            }
        };

        var chart = new google.charts.Line(document.getElementById('line_top_x'));

        chart.draw(data, google.charts.Line.convertOptions(options));
    }

	// Функция рассчета и персетройки графика
    function reload() {
        // Основная программа
        console.log("Lagrange's interpolation");

        // Две части, ненужную закомментировать


        // Часть первая: известен интервал и функция, выполняем разбиение для многочлена степени n (на n+1 узлов):

        // получаем элемент printBlock
        var A = document.getElementById("A").value;
        // получаем новое значение
        a = parseFloat(A);

        var B = document.getElementById("B").value;
        b = parseFloat(B);

        var N = document.getElementById("SIZE").value;
        n = parseFloat(N);

        //var n = 3; // Многочлен степени 2 = число узлов 3
        //var a = -1.0; var b = 2.0; // Интервал
        var xx = 1.5; // Точка внутри интервала, для которой выполняется интерполяция
        // а f - функция исходная, нам она нужна чтобы посчитать в узлах значения f(x)
        // Выполняем интерполяцию через вспомогательную функцию:
        var yy = interpolate1(a, b, n+1, xx);
        // А также вычисляем истинное значение функции в этой точке:
        var y = f(xx);
        // Выводим результат:
        console.log("L" + n + "(" + xx + ") = " + yy);
        console.log("F" + "(" + xx + ") = " + y);


        // Часть вторая: известны узловые точки и функция, выполняем интерполяцию для xx:
        var myX = []; // Создаем пустой массив X
        myX.push(1.0);  // добавляем в конец массива
        myX.push(2.0);
        myX.push(3.0);

        var myY = []; // Создаем пустой массив Y
        myY.push(-2.0);
        myY.push(1.0);
        myY.push(6.0);

        var xx1 = 2.5; // Точка внутри интервала, для которой выполняется интерполяция
        // а f - функция исходная, нам она нужна чтобы посчитать в узлах значения f(x)
        // Выполняем интерполяцию через основную функцию:
        var yy1 = interpolate2(myX, myY, xx1);
        // А также вычисляем истинное значение функции в этой точке:
        var y1 = f(xx1);
        // Выводим результат:
        console.log("L" + (myX.length-1) + "(" + xx1 + ") = " + yy1);
        console.log("F" + "(" + xx1 + ") = " + y1);


        // А теперь рисуем график
        google.charts.load('current', {'packages':['line']});
        google.charts.setOnLoadCallback(drawChart);

    }


// Основная программа

var n = 3; // Многочлен степени 2 = число узлов 3
var a = -1.0; var b = 2.0; // Интервал
var xx = 1.5; // Точка внутри интервала, для которой выполняется интерполяция
reload();