function cc = coefMNKDiscrete(X, Y, n)
% Дискретный метод вычисления коэфиициентов аппроксимирующего полинома

N = length(X); % Количество узловых точек
syms x; %Определение символьной переменной

c = sym('c', [1 n]); % Определяем массив символьных переменных с1, ..., сn

% 1 Собираем матрицу уравнений:
u = sym('u', [1 n]); % Определяем массив символьных переменных u1, ..., un
% Для каждой символьной переменной формируем содержимое:
for k = 1:n % от u1 до u(n-1)
    % 1.1 Считаем левую сумму:
    summ_L = 0;
    % Организуем цикл по переменным ci
    for i = 1:n % от c1 до c(n-1)
        % 1.1 Для каждой переменной ci организуем цикл по фj (считаем <фi,фk>):
        for j = 1:N
           summ_L = summ_L + ( X(j)^(i-1) ) * ( X(j)^(k-1) ) * c(i);
        end
    end
    % 1.2 Нормируем
    summ_L = 1/N * summ_L;
    
    % 1.3 Считаем правую сумму:
    summ_R = 0;
    % Организуем цикл по по fj (считаем <f,фk>):
    for j = 1:N
        summ_R = summ_R + Y(j) * ( X(j)^(k-1) );        
    end
    % 1.4 Нормируем
    summ_R = 1/N * summ_R;    
    
    % 1.5 Вычитаем из левой суммы правую и окончательно формируем уравнение:
    summ = summ_L - summ_R;  
    % 1.6 Переводим к символьному виду и записываем в соответсвующий 
    % элемент символьной матрицы уравнений
    u(k) = sym(summ); 
end
    
% 2 Символьно решаем систему линейных алгебраических уравнений
c = solve (u);
% c.c1
% c.c2

% 3 Получаем массив строк с именами всех полей структуры "c":
cname = fieldnames(c);

% 4 Получаем содержимое каждого поля структуры, обращаясь по имени поля, и
% конвертируем в double, сохраняя в итоговый массив
for i = 1:n % от c1 до сn-1
    %getfield(S, 'field') — возвращает содержимое поля структуры S, что эквивалентно S. field;
    cname_cell = cname(i);
    cc(i) = double(getfield(c, cname_cell{1})); % Фигурные скобки для обращения к содержимому ячейки
end

end